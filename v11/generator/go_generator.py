"""
Go 代码生成器
根据 API 定义、事件定义等生成对应的 Go 代码
"""

from typing import List, Optional
from schema import Field, APIModel, APIDefinition, EventModel, FieldType, MessageTypeVariant, MessageSegment
from type_mapper import TypeMapper


class GoCodeGenerator:
    """Go 代码生成器"""

    def __init__(self, package_name: str = "onebot"):
        self.package_name = package_name
        self.type_mapper = TypeMapper()

    def generate_model_file_header(self) -> str:
        """生成文件头"""
        return f"""// Code generated by onebot-11-go-sdk generator. DO NOT EDIT.
package {self.package_name}

import (
    "encoding/json"
)

"""

    def generate_api_models(self, api_def: APIDefinition) -> str:
        """
        为一个 API 生成请求和响应模型代码

        Args:
            api_def: API 定义

        Returns:
            生成的 Go 代码
        """
        code_parts = []

        # 生成请求模型
        code_parts.append(self._generate_request_model(api_def))
        code_parts.append("\n")

        # 生成响应模型
        code_parts.append(self._generate_response_model(api_def))

        return "\n".join(code_parts)

    def _generate_request_model(self, api_def: APIDefinition) -> str:
        """生成请求模型结构体"""
        model = api_def.request_model
        model_name = self._snake_to_pascal(api_def.api_name) + "Request"

        code_lines = [
            f"// {model_name} 表示 {api_def.api_name} API 的请求参数",
            f"// 对应文档: {api_def.description}",
            f"type {model_name} struct {{",
        ]

        for field in model.fields:
            code_lines.append(self._generate_field_code(field))

        code_lines.append("}")

        return "\n".join(code_lines)

    def _generate_response_model(self, api_def: APIDefinition) -> str:
        """生成响应模型结构体"""
        model = api_def.response_model
        model_name = self._snake_to_pascal(api_def.api_name) + "Response"

        code_lines = [
            f"// {model_name} 表示 {api_def.api_name} API 的响应数据",
            f"type {model_name} struct {{",
        ]

        if model.fields:
            for field in model.fields:
                code_lines.append(self._generate_field_code(field))
        else:
            # 如果没有响应字段，添加一个空响应体
            code_lines.append("    // 无响应数据")

        code_lines.append("}")

        return "\n".join(code_lines)

    def _generate_field_code(self, field: Field) -> str:
        """
        生成字段代码

        Args:
            field: 字段定义

        Returns:
            Go 字段代码行
        """
        # 构建字段注释
        comment = self._build_field_comment(field)

        # 处理特殊的 MESSAGE 类型
        if field.field_type == FieldType.MESSAGE:
            return self._generate_message_field(field, comment)

        # 处理其他类型
        go_type, use_omitempty = self.type_mapper.determine_go_type_with_omitempty(
            field.field_type, field.go_type, field.required, field.default_value
        )

        tag = self._build_json_tag(field.name, use_omitempty)

        return f"    // {comment}\n    {field.go_name} {go_type} `json:\"{tag}\"`"  # 移除了额外的反引号

    def _generate_message_field(self, field: Field, comment: str) -> str:
        """
        生成 MESSAGE 类型字段代码

        对于 message 字段，使用 oneof 思想的自定义类型来精确表示
        message 可以是：
        1. 纯文本字符串
        2. 消息段对象数组

        这里生成的是联合类型（使用 interface{}，但带有类型信息）
        """
        tag = self._build_json_tag(field.name, field.is_optional)

        # 对于 message 类型，我们生成一个特殊的 MessageValue 类型
        # 它可以是字符串或 []MessageSegment
        return f"""    // {comment}
    // 可以是字符串 (CQ 码格式) 或消息段数组
    {field.go_name} MessageValue `json:"{tag}"`"""

    def _build_field_comment(self, field: Field) -> str:
        """生成字段注释"""
        parts = [field.description]

        if field.default_value and field.default_value.strip():
            parts.append(f"默认值: {field.default_value}")

        if field.possible_values:
            possible = ", ".join(field.possible_values)
            parts.append(f"可能的值: {possible}")

        return " | ".join(parts)

    def _build_json_tag(self, field_name: str, use_omitempty: bool = False) -> str:
        """
        生成 JSON tag

        Args:
            field_name: 字段名
            use_omitempty: 是否添加 omitempty

        Returns:
            JSON tag 字符串
        """
        if use_omitempty:
            return f"{field_name},omitempty"
        return field_name

    def generate_message_value_type(self) -> str:
        """
        生成 MessageValue 类型定义
        这是一个自定义类型，用来精确表示 message 字段的可能类型

        使用 Proto oneof 的思想：
        - String: 纯文本字符串
        - Array: 消息段数组
        """
        return '''// MessageValue 表示 OneBot message 字段的值
// 可以是纯文本字符串或消息段数组
// 这种设计参考了 Proto3 的 oneof 思想，避免使用 interface{}
type MessageValue struct {
    // 如果 Type 为 "string"，则使用 StringValue
    // 如果 Type 为 "array"，则使用 ArrayValue
    Type       string                `json:"-"`
    StringValue string                `json:"string_value,omitempty"`
    ArrayValue  []MessageSegment       `json:"array_value,omitempty"`
}

// MessageSegment 表示一个消息段
type MessageSegment struct {
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}

// UnmarshalJSON 实现 json.Unmarshaler 接口
// 用于在反序列化时自动选择正确的类型
func (m *MessageValue) UnmarshalJSON(data []byte) error {
    // 首先尝试作为字符串解析
    var str string
    if err := json.Unmarshal(data, &str); err == nil {
        m.Type = "string"
        m.StringValue = str
        return nil
    }

    // 然后尝试作为数组解析
    var arr []MessageSegment
    if err := json.Unmarshal(data, &arr); err == nil {
        m.Type = "array"
        m.ArrayValue = arr
        return nil
    }

    return json.Unmarshal(data, &struct{}{})
}

// MarshalJSON 实现 json.Marshaler 接口
// 用于在序列化时正确地输出值
func (m *MessageValue) MarshalJSON() ([]byte, error) {
    if m.Type == "string" {
        return json.Marshal(m.StringValue)
    }
    if m.Type == "array" {
        return json.Marshal(m.ArrayValue)
    }
    return []byte("null"), nil
}
'''

    def _snake_to_pascal(self, snake_str: str) -> str:
        """将 snake_case 转换为 PascalCase"""
        return self.type_mapper.snake_to_pascal(snake_str)

    def generate_all_apis(self, apis: List[APIDefinition]) -> str:
        """
        生成所有 API 的模型代码

        Args:
            apis: API 定义列表

        Returns:
            生成的 Go 代码
        """
        code_parts = [self.generate_model_file_header()]

        # 添加 MessageValue 类型定义
        code_parts.append(self.generate_message_value_type())
        code_parts.append("\n\n")

        # 生成每个 API 的模型
        for api_def in apis:
            code_parts.append(self.generate_api_models(api_def))
            code_parts.append("\n\n")

        return "\n".join(code_parts)

    def generate_all_events(self, events: List[EventModel]) -> str:
        """
        生成所有事件的模型代码

        Args:
            events: 事件定义列表

        Returns:
            生成的 Go 代码
        """
        code_parts = [self.generate_model_file_header(), self.generate_message_value_type(), "\n\n"]

        # 添加 MessageValue 类型定义

        # 生成每个事件的模型
        for event in events:
            code_parts.append(self._generate_event_model(event))
            code_parts.append("\n\n")

        return "\n".join(code_parts)

    def _generate_event_model(self, event: EventModel) -> str:
        """
        生成单个事件的 Go 结构体代码

        Args:
            event: 事件模型

        Returns:
            生成的 Go 代码
        """
        # 生成事件结构体名称（去掉特殊字符，转为 PascalCase）
        struct_name = self._event_name_to_struct_name(event.name)

        # 生成注释
        comment_lines = [
            f"// {struct_name} {event.description}",
        ]
        if event.event_type:
            comment_lines.append(f"// 事件类型: {event.event_type}")
        if event.sub_type:
            comment_lines.append(f"// 子类型: {event.sub_type}")

        code_parts = [
            "\n".join(comment_lines),
            f"type {struct_name} struct {{",
        ]

        # 生成字段
        for field in event.fields:
            field_code = self._generate_field_code(field)
            code_parts.append(field_code)

        code_parts.append("}")

        return "\n".join(code_parts)

    def _event_name_to_struct_name(self, event_name: str) -> str:
        """
        将事件名称转换为 Go 结构体名称

        Args:
            event_name: 事件名称（如"私聊消息"、"群文件上传"）

        Returns:
            Go 结构体名称（如"PrivateMessageEvent"、"GroupFileUploadEvent"）
        """
        # 事件名称映射表
        name_mapping = {
            "私聊消息": "PrivateMessageEvent",
            "群消息": "GroupMessageEvent",
            "群文件上传": "GroupFileUploadEvent",
            "群管理员变动": "GroupAdminChangeEvent",
            "群成员减少": "GroupMemberDecreaseEvent",
            "群成员增加": "GroupMemberIncreaseEvent",
            "群禁言": "GroupBanEvent",
            "好友添加": "FriendAddEvent",
            "群消息撤回": "GroupRecallEvent",
            "好友消息撤回": "FriendRecallEvent",
            "群内戳一戳": "GroupPokeEvent",
            "群红包运气王": "GroupLuckyKingEvent",
            "群成员荣誉变更": "GroupHonorChangeEvent",
            "加好友请求": "FriendRequestEvent",
            "加群请求／邀请": "GroupRequestEvent",
            "生命周期": "LifecycleEvent",
            "心跳": "HeartbeatEvent",
        }

        # 如果有映射，使用映射的名称
        if event_name in name_mapping:
            return name_mapping[event_name]

        # 否则尝试简单转换（去掉斜杠、空格等特殊字符）
        clean_name = event_name.replace("／", "").replace("/", "").replace(" ", "")
        return f"{clean_name}Event"

    def generate_all_message_segments(self, segments: List[MessageSegment]) -> str:
        """
        生成所有消息段的模型代码

        Args:
            segments: 消息段定义列表

        Returns:
            生成的 Go 代码
        """
        code_parts = [self.generate_model_file_header()]

        # 生成基础的 MessageSegment 结构体
        code_parts.append(self._generate_base_message_segment())
        code_parts.append("\n\n")

        # 生成每个消息段的专用结构体
        for segment in segments:
            code_parts.append(self._generate_message_segment_model(segment))
            code_parts.append("\n\n")

        # 生成辅助方法
        code_parts.append(self._generate_message_segment_helpers(segments))

        return "\n".join(code_parts)

    def _generate_base_message_segment(self) -> str:
        """
        生成基础的 MessageSegment 结构体定义
        """
        return '''// MessageSegment 表示一个通用消息段
// 所有具体的消息段类型都应该能转换为此类型
type MessageSegment struct {
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}'''

    def _generate_message_segment_model(self, segment: MessageSegment) -> str:
        """
        生成单个消息段的 Go 结构体代码

        Args:
            segment: 消息段模型

        Returns:
            生成的 Go 代码
        """
        # 生成结构体名称
        struct_name = self._message_segment_type_to_struct_name(segment.segment_type)

        # 生成注释
        send_recv_info = []
        if segment.can_send:
            send_recv_info.append("支持发送")
        if segment.can_receive:
            send_recv_info.append("支持接收")
        send_recv_str = "、".join(send_recv_info) if send_recv_info else "未知"

        comment_lines = [
            f"// {struct_name} {segment.description}",
            f"// 消息段类型: {segment.segment_type}",
            f"// {send_recv_str}",
        ]

        code_parts = [
            "\n".join(comment_lines),
            f"type {struct_name} struct {{",
        ]

        # 生成字段
        if segment.fields:
            for field in segment.fields:
                field_code = self._generate_field_code(field)
                code_parts.append(field_code)
        else:
            code_parts.append("    // 无参数")

        code_parts.append("}")

        # 生成转换方法
        code_parts.append("")
        code_parts.append(self._generate_to_message_segment_method(struct_name, segment.segment_type, segment.fields))

        return "\n".join(code_parts)

    def _message_segment_type_to_struct_name(self, segment_type: str) -> str:
        """
        将消息段类型转换为 Go 结构体名称

        Args:
            segment_type: 消息段类型（如"text"、"image"）

        Returns:
            Go 结构体名称（如"TextSegment"、"ImageSegment"）
        """
        # 消息段类型映射表
        name_mapping = {
            "text": "TextSegment",
            "face": "FaceSegment",
            "image": "ImageSegment",
            "record": "RecordSegment",
            "video": "VideoSegment",
            "at": "AtSegment",
            "rps": "RpsSegment",
            "dice": "DiceSegment",
            "shake": "ShakeSegment",
            "poke": "PokeSegment",
            "anonymous": "AnonymousSegment",
            "share": "ShareSegment",
            "contact": "ContactSegment",
            "location": "LocationSegment",
            "music": "MusicSegment",
            "reply": "ReplySegment",
            "forward": "ForwardSegment",
            "node": "NodeSegment",
            "xml": "XmlSegment",
            "json": "JsonSegment",
        }

        # 如果有映射，使用映射的名称
        if segment_type in name_mapping:
            return name_mapping[segment_type]

        # 否则使用 PascalCase 转换
        return self._snake_to_pascal(segment_type) + "Segment"

    def _generate_to_message_segment_method(self, struct_name: str, segment_type: str, fields: List[Field]) -> str:
        """
        生成转换为 MessageSegment 的方法

        Args:
            struct_name: 结构体名称
            segment_type: 消息段类型
            fields: 字段列表

        Returns:
            方法代码
        """
        code_lines = [
            f"// ToMessageSegment 将 {struct_name} 转换为通用 MessageSegment",
            f"func (s *{struct_name}) ToMessageSegment() MessageSegment {{",
            "    data := make(map[string]interface{})",
        ]

        # 为每个字段生成赋值代码
        for field in fields:
            # 使用字段的 JSON 名称作为 map 的 key
            code_lines.append(f"    data[\"{field.name}\"] = s.{field.go_name}")

        code_lines.extend([
            "    return MessageSegment{",
            f"        Type: \"{segment_type}\",",
            "        Data: data,",
            "    }",
            "}",
        ])

        return "\n".join(code_lines)

    def _generate_message_segment_helpers(self, segments: List[MessageSegment]) -> str:
        """
        生成消息段辅助函数

        Args:
            segments: 消息段列表

        Returns:
            辅助函数代码
        """
        return '''// NewTextSegment 创建文本消息段
func NewTextSegment(text string) MessageSegment {
    return MessageSegment{
        Type: "text",
        Data: map[string]interface{}{"text": text},
    }
}

// NewImageSegment 创建图片消息段
func NewImageSegment(file string) MessageSegment {
    return MessageSegment{
        Type: "image",
        Data: map[string]interface{}{"file": file},
    }
}

// NewAtSegment 创建 @ 消息段
func NewAtSegment(qq string) MessageSegment {
    return MessageSegment{
        Type: "at",
        Data: map[string]interface{}{"qq": qq},
    }
}'''
