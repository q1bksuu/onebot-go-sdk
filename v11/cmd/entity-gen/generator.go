package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path"
	"sort"
	"strings"
	"text/template"
	"unicode"
)

const fileTemplateText = `// Code generated by entity-gen. DO NOT EDIT.

package {{.Package}}
{{- if .Imports}}

import (
{{- range .Imports}}
    "{{.}}"
{{- end}}
)
{{- end}}

{{range .Structs}}
{{range .Fields}}

{{/* Getter */}}
{{if .HasComments}}// {{.GetterName}}
{{.Comments}}
{{- end}}
func (r *{{.ReceiverWithParams}}) {{.GetterName}}() {{.ReturnType}} {
    if r == nil {
        var zero {{.ReturnType}}
        return zero
    }
{{- if .IsBasicPointer}}
    if r.{{.FieldName}} == nil {
        var zero {{.ReturnType}}
        return zero
    }
    return *r.{{.FieldName}}
{{- else}}
    return r.{{.FieldName}}
{{- end}}
}

{{/* Setter */}}
{{if .HasComments}}// {{.SetterName}}
{{.Comments}}
{{- end}}
func (r *{{.ReceiverWithParams}}) {{.SetterName}}(v {{.ParamType}}) *{{.ReceiverWithParams}} {
{{- if .IsBasicPointer}}
    val := v
    r.{{.FieldName}} = &val
{{- else}}
    r.{{.FieldName}} = v
{{- end}}
    return r
}

{{- end}}
{{- end}}
`

var (
	errFileNotExist   = errors.New("file does not exist")
	errStructNotFound = errors.New("struct types not found")

	//nolint:gochecknoglobals
	fileTemplate = template.Must(template.New("file").Parse(fileTemplateText))
)

type fieldInfo struct {
	name               string
	typeName           string
	isPointer          bool
	isBasic            bool
	comments           string
	receiverType       string
	receiverTypeParams string
}

type templateField struct {
	HasComments        bool
	Comments           string
	ReceiverWithParams string
	GetterName         string
	SetterName         string
	ReturnType         string
	ParamType          string
	FieldName          string
	IsBasicPointer     bool
}

type templateStruct struct {
	Fields []templateField
}

type structDef struct {
	name       string
	typeParams string
	structType *ast.StructType
}

type Generator struct {
	filename          string
	fileSet           *token.FileSet
	astFile           *ast.File
	customTypeAliases map[string]bool // 缓存自定义类型别名（如 string 的别名）
	basicTypesCache   map[string]bool // Go基本类型缓存，提升性能
}

func NewGenerator(filename string, constFiles []string) (*Generator, error) {
	// 检查文件是否存在
	_, err := os.Stat(filename)
	if err != nil && os.IsNotExist(err) {
		return nil, fmt.Errorf("%w: %s", errFileNotExist, filename)
	}

	fileSet := token.NewFileSet()

	astFile, err := parser.ParseFile(fileSet, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse astFile %s: %w", filename, err)
	}

	gen := &Generator{
		filename:          filename,
		fileSet:           fileSet,
		astFile:           astFile,
		customTypeAliases: make(map[string]bool),
		basicTypesCache:   initBasicTypesCache(),
	}

	// 扫描主文件中的自定义类型别名定义
	gen.collectCustomTypeAliases()

	// 扫描额外的 consts 文件中的自定义类型别名定义
	for _, constFile := range constFiles {
		err = gen.collectCustomTypeAliasesFromFile(constFile)
		if err != nil {
			return nil, fmt.Errorf("failed to collect custom type: %w", err)
		}
	}

	return gen, nil
}

func (g *Generator) Generate(targetTypes []string) (string, error) {
	structDefs := g.findStructs(targetTypes)
	if len(structDefs) == 0 {
		return "", fmt.Errorf("%w: %v", errStructNotFound, targetTypes)
	}

	tmplStructs := make([]templateStruct, 0, len(structDefs))
	for _, sd := range structDefs {
		fields := g.extractFields(sd.structType, sd.name, sd.typeParams)
		tmplFields := g.buildTemplateFields(fields)
		tmplStructs = append(tmplStructs, templateStruct{Fields: tmplFields})
	}

	imports := g.collectImports(tmplStructs)

	data := struct {
		Package string
		Imports []string
		Structs []templateStruct
	}{
		Package: g.astFile.Name.Name,
		Imports: imports,
		Structs: tmplStructs,
	}

	var buf bytes.Buffer

	err := fileTemplate.Execute(&buf, data)
	if err != nil {
		return "", fmt.Errorf("failed to render file template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("failed to format generated code: %w", err)
	}

	return string(formatted), nil
}

func (g *Generator) findStructs(targetTypes []string) []structDef {
	var result []structDef

	targetTypeSet := make(map[string]struct{}, len(targetTypes))
	for _, targetType := range targetTypes {
		targetTypeSet[targetType] = struct{}{}
	}

	for _, decl := range g.astFile.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// 如果指定了类型名，仅处理该类型
			if len(targetTypeSet) > 0 {
				_, ok = targetTypeSet[typeSpec.Name.Name]
				if !ok {
					continue
				}
			}

			result = append(result, structDef{
				name:       typeSpec.Name.Name,
				typeParams: g.typeParamsToString(typeSpec.TypeParams),
				structType: structType,
			})
		}
	}

	return result
}

func (g *Generator) buildTemplateFields(fields []fieldInfo) []templateField {
	res := make([]templateField, 0, len(fields))
	for _, field := range fields {
		returnType := field.typeName

		paramType := field.typeName
		if !field.isBasic && field.isPointer {
			returnType = "*" + returnType
			paramType = "*" + paramType
		}

		receiverWithParams := field.receiverType
		if field.receiverTypeParams != "" {
			receiverWithParams += field.receiverTypeParams
		}

		exportedName := toExportedName(field.name)
		tmplField := templateField{
			HasComments:        field.comments != "",
			Comments:           field.comments,
			ReceiverWithParams: receiverWithParams,
			GetterName:         "Get" + exportedName,
			SetterName:         "Set" + exportedName,
			ReturnType:         returnType,
			ParamType:          paramType,
			FieldName:          field.name,
			IsBasicPointer:     field.isBasic && field.isPointer,
		}

		res = append(res, tmplField)
	}

	return res
}

func (g *Generator) extractFields(
	structType *ast.StructType,
	receiverType string,
	receiverTypeParams string,
) []fieldInfo {
	var result []fieldInfo

	if structType.Fields == nil || structType.Fields.List == nil {
		return result
	}

	for _, field := range structType.Fields.List {
		// 处理嵌入字段（匿名字段）
		if len(field.Names) == 0 {
			typeName := g.getTypeName(field.Type)
			if typeName != "" && isExported(typeName) {
				isPointer, baseType := g.unwrapPointer(field.Type)
				isBasic := g.isBasicType(baseType)
				comments := g.extractComments(field)

				result = append(result, fieldInfo{
					name:               typeName,
					typeName:           g.typeToString(baseType),
					isPointer:          isPointer,
					isBasic:            isBasic,
					comments:           comments,
					receiverType:       receiverType,
					receiverTypeParams: receiverTypeParams,
				})
			}

			continue
		}

		// 处理普通命名字段
		for _, name := range field.Names {
			fieldName := name.Name

			// 跳过未导出的字段
			if !isExported(fieldName) {
				continue
			}

			isPointer, baseType := g.unwrapPointer(field.Type)
			isBasic := g.isBasicType(baseType)

			comments := g.extractComments(field)

			result = append(result, fieldInfo{
				name:               fieldName,
				typeName:           g.typeToString(baseType),
				isPointer:          isPointer,
				isBasic:            isBasic,
				comments:           comments,
				receiverType:       receiverType,
				receiverTypeParams: receiverTypeParams,
			})
		}
	}

	return result
}

func (g *Generator) collectImports(structs []templateStruct) []string {
	importsSet := make(map[string]struct{})
	aliasToPath := g.buildAliasToPathMap()

	for _, st := range structs {
		g.collectStructImports(st, aliasToPath, importsSet)
	}

	if len(importsSet) == 0 {
		return nil
	}

	imports := make([]string, 0, len(importsSet))
	for imp := range importsSet {
		imports = append(imports, imp)
	}

	sort.Strings(imports)

	return imports
}

func (g *Generator) buildAliasToPathMap() map[string]string {
	aliasToPath := make(map[string]string)

	for _, imp := range g.astFile.Imports {
		if imp.Path == nil {
			continue
		}

		importPath := strings.Trim(imp.Path.Value, `"`)

		var alias string

		if imp.Name != nil && imp.Name.Name != "" {
			// 忽略占位或点导入，无法可靠判断类型前缀
			if imp.Name.Name == "_" || imp.Name.Name == "." {
				continue
			}

			alias = imp.Name.Name
		} else {
			alias = path.Base(importPath)
		}

		if alias == "" {
			continue
		}

		aliasToPath[alias] = importPath
	}

	return aliasToPath
}

func (g *Generator) collectStructImports(
	st templateStruct,
	aliasToPath map[string]string,
	importsSet map[string]struct{},
) {
	for _, f := range st.Fields {
		for alias, importPath := range aliasToPath {
			if strings.Contains(f.ReturnType, alias+".") || strings.Contains(f.ParamType, alias+".") {
				importsSet[importPath] = struct{}{}
			}
		}
	}
}

func (g *Generator) getTypeName(expr ast.Expr) string {
	switch exprType := expr.(type) {
	case *ast.Ident:
		return exprType.Name
	case *ast.SelectorExpr:
		return exprType.Sel.Name
	case *ast.StarExpr:
		return g.getTypeName(exprType.X)
	case *ast.IndexExpr:
		// single type argument
		return g.getTypeName(exprType.X)
	case *ast.IndexListExpr:
		return g.getTypeName(exprType.X)
	default:
		return ""
	}
}

func (g *Generator) unwrapPointer(expr ast.Expr) (bool, ast.Expr) {
	if starExpr, ok := expr.(*ast.StarExpr); ok {
		return true, starExpr.X
	}

	return false, expr
}

func (g *Generator) isBasicType(expr ast.Expr) bool {
	ident, ok := expr.(*ast.Ident)

	return ok && (g.basicTypesCache[ident.Name] || g.customTypeAliases[ident.Name])
}

//nolint:cyclop
func (g *Generator) typeToString(expr ast.Expr) string {
	switch exprType := expr.(type) {
	case *ast.Ident:
		return exprType.Name
	case *ast.SelectorExpr:
		return g.typeToString(exprType.X) + "." + exprType.Sel.Name
	case *ast.ArrayType:
		if exprType.Len == nil {
			return "[]" + g.typeToString(exprType.Elt)
		}

		return "[" + g.typeToString(exprType.Len) + "]" + g.typeToString(exprType.Elt)
	case *ast.MapType:
		return "map[" + g.typeToString(exprType.Key) + "]" + g.typeToString(exprType.Value)
	case *ast.StarExpr:
		return "*" + g.typeToString(exprType.X)
	case *ast.IndexExpr:
		return g.typeToString(exprType.X) + "[" + g.typeToString(exprType.Index) + "]"
	case *ast.IndexListExpr:
		parts := make([]string, 0, len(exprType.Indices))
		for _, idx := range exprType.Indices {
			parts = append(parts, g.typeToString(idx))
		}

		return g.typeToString(exprType.X) + "[" + strings.Join(parts, ",") + "]"
	default:
		panic(fmt.Sprintf("type %T not supported", exprType))
	}
}

func (g *Generator) extractComments(field *ast.Field) string {
	if field.Doc == nil && field.Comment == nil {
		return ""
	}

	var commentList []*ast.Comment

	// 优先使用 Doc 注释，然后是行尾注释
	if field.Doc != nil {
		commentList = field.Doc.List
	} else if field.Comment != nil {
		commentList = field.Comment.List
	}

	comments := make([]string, 0, len(commentList))
	for _, comment := range commentList {
		text := strings.TrimPrefix(comment.Text, "//")

		text = strings.TrimSpace(text)
		if text != "" {
			// 处理多行注释的情况
			lines := strings.Split(text, "\n")
			for _, line := range lines {
				line = strings.TrimSpace(line)
				if line != "" {
					comments = append(comments, "// "+line)
				}
			}
		}
	}

	return strings.Join(comments, "\n")
}

func (g *Generator) typeParamsToString(typeParams *ast.FieldList) string {
	if typeParams == nil || len(typeParams.List) == 0 {
		return ""
	}

	parts := make([]string, 0, len(typeParams.List))
	for _, p := range typeParams.List {
		for _, name := range p.Names {
			parts = append(parts, name.Name)
		}
	}

	if len(parts) == 0 {
		return ""
	}

	return "[" + strings.Join(parts, ",") + "]"
}

// 初始化 Go 基本类型缓存，O(1) 查询性能.
func initBasicTypesCache() map[string]bool {
	return map[string]bool{
		"bool":       true,
		"byte":       true,
		"complex64":  true,
		"complex128": true,
		"error":      true,
		"float32":    true,
		"float64":    true,
		"int":        true,
		"int8":       true,
		"int16":      true,
		"int32":      true,
		"int64":      true,
		"rune":       true,
		"string":     true,
		"uint":       true,
		"uint8":      true,
		"uint16":     true,
		"uint32":     true,
		"uint64":     true,
		"uintptr":    true,
	}
}

// 收集文件中的自定义类型别名定义
// 特别是那些基于基本类型（如 string）的别名类型.
func (g *Generator) collectCustomTypeAliases() {
	g.collectTypeAliasesFromAST(g.astFile)
}

// collectCustomTypeAliasesFromFile 从额外的文件中收集自定义类型别名
// 这个方法用来扫描 *_consts.go 这样的类型定义文件.
func (g *Generator) collectCustomTypeAliasesFromFile(filepath string) error {
	f, err := parser.ParseFile(g.fileSet, filepath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse consts file %s: %w", filepath, err)
	}

	g.collectTypeAliasesFromAST(f)

	return nil
}

// collectTypeAliasesFromAST 从 AST 节点中收集自定义类型别名.
func (g *Generator) collectTypeAliasesFromAST(file *ast.File) {
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// 检查是否是类型别名而非结构体定义
			// 比如: type MyString string
			ident, ok := typeSpec.Type.(*ast.Ident)
			if !ok {
				continue
			}

			// 如果这个类型的基础类型是 Go 内置类型，则将其记录为自定义类型别名
			// 这样在生成 getter/setter 时，就能正确处理这些别名类型
			if g.basicTypesCache[ident.Name] {
				g.customTypeAliases[typeSpec.Name.Name] = true
			}
		}
	}
}

func toExportedName(name string) string {
	if len(name) == 0 {
		return name
	}

	return strings.ToUpper(name[:1]) + name[1:]
}

func isExported(name string) bool {
	if len(name) == 0 {
		return false
	}

	return unicode.IsUpper(rune(name[0]))
}
