package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"unicode"
)

type fieldInfo struct {
	name         string
	typeName     string
	isPointer    bool
	isBasic      bool
	comments     string
	receiverType string
}

type Generator struct {
	filename          string
	fileSet           *token.FileSet
	file              *ast.File
	customTypeAliases map[string]bool // 缓存自定义类型别名（如 string 的别名）
	basicTypesCache   map[string]bool // Go基本类型缓存，提升性能
}

func NewGenerator(filename string, constFiles []string) (*Generator, error) {
	// 检查文件是否存在
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		return nil, fmt.Errorf("file %s does not exist", filename)
	}

	fileSet := token.NewFileSet()
	f, err := parser.ParseFile(fileSet, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file %s: %w", filename, err)
	}

	gen := &Generator{
		filename:          filename,
		fileSet:           fileSet,
		file:              f,
		customTypeAliases: make(map[string]bool),
		basicTypesCache:   initBasicTypesCache(),
	}

	// 扫描主文件中的自定义类型别名定义
	gen.collectCustomTypeAliases()

	// 扫描额外的 consts 文件中的自定义类型别名定义
	for _, constFile := range constFiles {
		err = gen.collectCustomTypeAliasesFromFile(constFile)
		if err != nil {
			return nil, fmt.Errorf("failed to collect custom type: %w", err)
		}
	}

	return gen, nil
}

func (g *Generator) Generate(targetTypes []string) (string, error) {
	var buf strings.Builder

	// 写入包声明
	buf.WriteString(`// Code generated by entity-gen. DO NOT EDIT.

package `)
	buf.WriteString(g.file.Name.Name)
	buf.WriteString("\n\n")

	structDefs := g.findStructs(targetTypes)
	if len(structDefs) == 0 {
		return "", fmt.Errorf("struct types %q not found", targetTypes)
	}
	for _, sd := range structDefs {
		methods := g.generateMethodsForStruct(sd.name, sd.structType)
		buf.WriteString(methods)
		buf.WriteByte('\n')
	}

	// 格式化输出
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		// 如果格式化失败，返回未格式化的版本，但提供错误信息
		return buf.String(), fmt.Errorf("failed to format generated code: %w", err)
	}
	return string(formatted), nil
}

type structDef struct {
	name       string
	structType *ast.StructType
}

func (g *Generator) findStructs(targetTypes []string) []structDef {
	var result []structDef
	targetTypeSet := make(map[string]struct{}, len(targetTypes))
	for _, targetType := range targetTypes {
		targetTypeSet[targetType] = struct{}{}
	}

	for _, decl := range g.file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// 如果指定了类型名，仅处理该类型
			if len(targetTypeSet) > 0 {
				_, ok = targetTypeSet[typeSpec.Name.Name]
				if !ok {
					continue
				}
			}

			result = append(result, structDef{
				name:       typeSpec.Name.Name,
				structType: structType,
			})
		}
	}

	return result
}

func (g *Generator) generateMethodsForStruct(structName string, st *ast.StructType) string {
	var buf strings.Builder

	if st.Fields == nil || st.Fields.List == nil {
		return ""
	}

	fields := g.extractFields(st, structName)
	methods := g.generateGettersAndSetters(fields)
	buf.WriteString(methods)

	return buf.String()
}

func (g *Generator) generateGettersAndSetters(fields []fieldInfo) string {
	var buf strings.Builder

	for _, field := range fields {
		// 生成getter
		getter := g.generateGetter(field)
		buf.WriteString(getter)
		buf.WriteString("\n\n")

		// 生成setter
		setter := g.generateSetter(field)
		buf.WriteString(setter)
		buf.WriteString("\n\n")
	}

	return buf.String()
}

func (g *Generator) extractFields(st *ast.StructType, receiverType string) []fieldInfo {
	var result []fieldInfo

	if st.Fields == nil || st.Fields.List == nil {
		return result
	}

	for _, field := range st.Fields.List {
		// 处理嵌入字段（匿名字段）
		if len(field.Names) == 0 {
			// 对于嵌入字段，我们尝试获取其类型名作为字段名
			typeName := g.getTypeName(field.Type)
			if typeName != "" && isExported(typeName) {
				isPointer, baseType := g.unwrapPointer(field.Type)
				isBasic := g.isBasicType(baseType)
				comments := g.extractComments(field)

				result = append(result, fieldInfo{
					name:         typeName,
					typeName:     g.typeToString(baseType),
					isPointer:    isPointer,
					isBasic:      isBasic,
					comments:     comments,
					receiverType: receiverType,
				})
			}
			continue
		}

		// 处理普通命名字段
		for _, name := range field.Names {
			fieldName := name.Name

			// 跳过未导出的字段
			if !isExported(fieldName) {
				continue
			}

			isPointer, baseType := g.unwrapPointer(field.Type)
			isBasic := g.isBasicType(baseType)

			comments := g.extractComments(field)

			result = append(result, fieldInfo{
				name:         fieldName,
				typeName:     g.typeToString(baseType),
				isPointer:    isPointer,
				isBasic:      isBasic,
				comments:     comments,
				receiverType: receiverType,
			})
		}
	}

	return result
}

func (g *Generator) generateGetter(field fieldInfo) string {
	methodName := "Get" + toExportedName(field.name)

	var codeBuilder strings.Builder
	if field.comments != "" {
		codeBuilder.WriteString("// ")
		codeBuilder.WriteString(methodName)
		codeBuilder.WriteByte('\n')
		codeBuilder.WriteString(field.comments)
		codeBuilder.WriteByte('\n')
	}

	returnType := field.typeName
	// 基本类型无论是否指针都返回非指针值
	if !field.isBasic && field.isPointer {
		returnType = "*" + returnType
	}

	codeBuilder.WriteString(fmt.Sprintf("func (r *%s) %s() %s {\n", field.receiverType, methodName, returnType))
	codeBuilder.WriteString(fmt.Sprintf(`if r == nil {
		var zero %s
		return zero
	}
`, returnType))

	if field.isBasic && field.isPointer {
		// 如果原字段是指针，需要解引用
		codeBuilder.WriteString(fmt.Sprintf(`if r.%s == nil {
		var zero %s
		return zero
	}
	return *r.%s`, field.name, returnType, field.name))
	} else {
		codeBuilder.WriteString(fmt.Sprintf(`return r.%s`, field.name))
	}
	codeBuilder.WriteByte('}')
	return codeBuilder.String()
}

func (g *Generator) generateSetter(field fieldInfo) string {
	methodName := "Set" + toExportedName(field.name)

	var codeBuilder strings.Builder
	if field.comments != "" {
		codeBuilder.WriteString("// ")
		codeBuilder.WriteString(methodName)
		codeBuilder.WriteByte('\n')
		codeBuilder.WriteString(field.comments)
		codeBuilder.WriteByte('\n')
	}

	paramType := field.typeName
	if !field.isBasic && field.isPointer {
		paramType = "*" + paramType
	}

	var assignment string
	if field.isBasic && field.isPointer {
		// 原字段是指针，但参数是非指针，需要取址
		assignment = fmt.Sprintf(`val := v
	r.%s = &val`, field.name)
	} else {
		assignment = fmt.Sprintf("r.%s = v", field.name)
	}
	codeBuilder.WriteString(fmt.Sprintf("func (r *%s) %s(v %s) *%s {",
		field.receiverType, methodName, paramType, field.receiverType))
	codeBuilder.WriteByte('\n')
	codeBuilder.WriteString(assignment)
	codeBuilder.WriteString("\nreturn r\n}")

	return codeBuilder.String()
}

func (g *Generator) getTypeName(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.Ident:
		return e.Name
	case *ast.SelectorExpr:
		return e.Sel.Name
	case *ast.StarExpr:
		return g.getTypeName(e.X)
	default:
		return ""
	}
}

func (g *Generator) unwrapPointer(expr ast.Expr) (bool, ast.Expr) {
	if starExpr, ok := expr.(*ast.StarExpr); ok {
		return true, starExpr.X
	}
	return false, expr
}

func (g *Generator) isBasicType(expr ast.Expr) bool {
	ident, ok := expr.(*ast.Ident)
	return ok && (g.basicTypesCache[ident.Name] || g.customTypeAliases[ident.Name])
}

func (g *Generator) typeToString(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.Ident:
		return e.Name
	case *ast.SelectorExpr:
		return g.typeToString(e.X) + "." + e.Sel.Name
	case *ast.ArrayType:
		if e.Len == nil {
			return "[]" + g.typeToString(e.Elt)
		}
		return "[" + g.typeToString(e.Len) + "]" + g.typeToString(e.Elt)
	case *ast.MapType:
		return "map[" + g.typeToString(e.Key) + "]" + g.typeToString(e.Value)
	case *ast.StarExpr:
		return "*" + g.typeToString(e.X)
	default:
		panic(fmt.Sprintf("type %T not supported", e))
	}
}

func (g *Generator) extractComments(field *ast.Field) string {
	if field.Doc == nil && field.Comment == nil {
		return ""
	}

	var commentList []*ast.Comment

	// 优先使用 Doc 注释，然后是行尾注释
	if field.Doc != nil {
		commentList = field.Doc.List
	} else if field.Comment != nil {
		commentList = field.Comment.List
	}

	comments := make([]string, 0, len(commentList))
	for _, comment := range commentList {
		text := strings.TrimPrefix(comment.Text, "//")
		text = strings.TrimSpace(text)
		if text != "" {
			// 处理多行注释的情况
			lines := strings.Split(text, "\n")
			for _, line := range lines {
				line = strings.TrimSpace(line)
				if line != "" {
					comments = append(comments, "// "+line)
				}
			}
		}
	}

	return strings.Join(comments, "\n")
}

// 初始化 Go 基本类型缓存，O(1) 查询性能
func initBasicTypesCache() map[string]bool {
	return map[string]bool{
		"bool":       true,
		"byte":       true,
		"complex64":  true,
		"complex128": true,
		"error":      true,
		"float32":    true,
		"float64":    true,
		"int":        true,
		"int8":       true,
		"int16":      true,
		"int32":      true,
		"int64":      true,
		"rune":       true,
		"string":     true,
		"uint":       true,
		"uint8":      true,
		"uint16":     true,
		"uint32":     true,
		"uint64":     true,
		"uintptr":    true,
	}
}

// 收集文件中的自定义类型别名定义
// 特别是那些基于基本类型（如 string）的别名类型
func (g *Generator) collectCustomTypeAliases() {
	g.collectTypeAliasesFromAST(g.file)
}

// collectCustomTypeAliasesFromFile 从额外的文件中收集自定义类型别名
// 这个方法用来扫描 *_consts.go 这样的类型定义文件
func (g *Generator) collectCustomTypeAliasesFromFile(filepath string) error {
	f, err := parser.ParseFile(g.fileSet, filepath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse consts file %s: %w", filepath, err)
	}

	g.collectTypeAliasesFromAST(f)
	return nil
}

// collectTypeAliasesFromAST 从 AST 节点中收集自定义类型别名
func (g *Generator) collectTypeAliasesFromAST(file *ast.File) {
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// 检查是否是类型别名而非结构体定义
			// 比如: type MyString string
			ident, ok := typeSpec.Type.(*ast.Ident)
			if !ok {
				continue
			}

			// 如果这个类型的基础类型是 Go 内置类型，则将其记录为自定义类型别名
			// 这样在生成 getter/setter 时，就能正确处理这些别名类型
			if g.basicTypesCache[ident.Name] {
				g.customTypeAliases[typeSpec.Name.Name] = true
			}
		}
	}
}

func toExportedName(name string) string {
	if len(name) == 0 {
		return name
	}
	return strings.ToUpper(name[:1]) + name[1:]
}

func isExported(name string) bool {
	if len(name) == 0 {
		return false
	}
	return unicode.IsUpper(rune(name[0]))
}
