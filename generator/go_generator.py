"""
Go 代码生成器
根据 API 定义、事件定义等生成对应的 Go 代码
"""

from typing import List, Optional
from schema import Field, APIModel, APIDefinition, FieldType, MessageTypeVariant
from type_mapper import TypeMapper


class GoCodeGenerator:
    """Go 代码生成器"""

    def __init__(self, package_name: str = "onebot"):
        self.package_name = package_name
        self.type_mapper = TypeMapper()

    def generate_model_file_header(self) -> str:
        """生成文件头"""
        return f"""// Code generated by onebot-11-go-sdk generator. DO NOT EDIT.
package {self.package_name}

import (
    "encoding/json"
)

"""

    def generate_api_models(self, api_def: APIDefinition) -> str:
        """
        为一个 API 生成请求和响应模型代码

        Args:
            api_def: API 定义

        Returns:
            生成的 Go 代码
        """
        code_parts = []

        # 生成请求模型
        code_parts.append(self._generate_request_model(api_def))
        code_parts.append("\n")

        # 生成响应模型
        code_parts.append(self._generate_response_model(api_def))

        return "\n".join(code_parts)

    def _generate_request_model(self, api_def: APIDefinition) -> str:
        """生成请求模型结构体"""
        model = api_def.request_model
        model_name = self._snake_to_pascal(api_def.api_name) + "Request"

        code_lines = [
            f"// {model_name} 表示 {api_def.api_name} API 的请求参数",
            f"// 对应文档: {api_def.description}",
            f"type {model_name} struct {{",
        ]

        for field in model.fields:
            code_lines.append(self._generate_field_code(field))

        code_lines.append("}")

        return "\n".join(code_lines)

    def _generate_response_model(self, api_def: APIDefinition) -> str:
        """生成响应模型结构体"""
        model = api_def.response_model
        model_name = self._snake_to_pascal(api_def.api_name) + "Response"

        code_lines = [
            f"// {model_name} 表示 {api_def.api_name} API 的响应数据",
            f"type {model_name} struct {{",
        ]

        if model.fields:
            for field in model.fields:
                code_lines.append(self._generate_field_code(field))
        else:
            # 如果没有响应字段，添加一个空响应体
            code_lines.append("    // 无响应数据")

        code_lines.append("}")

        return "\n".join(code_lines)

    def _generate_field_code(self, field: Field) -> str:
        """
        生成字段代码

        Args:
            field: 字段定义

        Returns:
            Go 字段代码行
        """
        # 构建字段注释
        comment = self._build_field_comment(field)

        # 处理特殊的 MESSAGE 类型
        if field.field_type == FieldType.MESSAGE:
            return self._generate_message_field(field, comment)

        # 处理其他类型
        go_type, use_omitempty = self.type_mapper.determine_go_type_with_omitempty(
            field.field_type, field.go_type, field.required, field.default_value
        )

        tag = self._build_json_tag(field.name, use_omitempty)

        return f"    // {comment}\n    {field.go_name} {go_type} `json:\"{tag}\"`"  # 移除了额外的反引号

    def _generate_message_field(self, field: Field, comment: str) -> str:
        """
        生成 MESSAGE 类型字段代码

        对于 message 字段，使用 oneof 思想的自定义类型来精确表示
        message 可以是：
        1. 纯文本字符串
        2. 消息段对象数组

        这里生成的是联合类型（使用 interface{}，但带有类型信息）
        """
        tag = self._build_json_tag(field.name, field.is_optional)

        # 对于 message 类型，我们生成一个特殊的 MessageValue 类型
        # 它可以是字符串或 []MessageSegment
        return f"""    // {comment}
    // 可以是字符串 (CQ 码格式) 或消息段数组
    {field.go_name} MessageValue `json:"{tag}"`"""

    def _build_field_comment(self, field: Field) -> str:
        """生成字段注释"""
        parts = [field.description]

        if field.default_value and field.default_value.strip():
            parts.append(f"默认值: {field.default_value}")

        if field.possible_values:
            possible = ", ".join(field.possible_values)
            parts.append(f"可能的值: {possible}")

        return " | ".join(parts)

    def _build_json_tag(self, field_name: str, use_omitempty: bool = False) -> str:
        """
        生成 JSON tag

        Args:
            field_name: 字段名
            use_omitempty: 是否添加 omitempty

        Returns:
            JSON tag 字符串
        """
        if use_omitempty:
            return f"{field_name},omitempty"
        return field_name

    def generate_message_value_type(self) -> str:
        """
        生成 MessageValue 类型定义
        这是一个自定义类型，用来精确表示 message 字段的可能类型

        使用 Proto oneof 的思想：
        - String: 纯文本字符串
        - Array: 消息段数组
        """
        return '''// MessageValue 表示 OneBot message 字段的值
// 可以是纯文本字符串或消息段数组
// 这种设计参考了 Proto3 的 oneof 思想，避免使用 interface{}
type MessageValue struct {
    // 如果 Type 为 "string"，则使用 StringValue
    // 如果 Type 为 "array"，则使用 ArrayValue
    Type       string                `json:"-"`
    StringValue string                `json:"string_value,omitempty"`
    ArrayValue  []MessageSegment       `json:"array_value,omitempty"`
}

// MessageSegment 表示一个消息段
type MessageSegment struct {
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}

// UnmarshalJSON 实现 json.Unmarshaler 接口
// 用于在反序列化时自动选择正确的类型
func (m *MessageValue) UnmarshalJSON(data []byte) error {
    // 首先尝试作为字符串解析
    var str string
    if err := json.Unmarshal(data, &str); err == nil {
        m.Type = "string"
        m.StringValue = str
        return nil
    }

    // 然后尝试作为数组解析
    var arr []MessageSegment
    if err := json.Unmarshal(data, &arr); err == nil {
        m.Type = "array"
        m.ArrayValue = arr
        return nil
    }

    return json.Unmarshal(data, &struct{}{})
}

// MarshalJSON 实现 json.Marshaler 接口
// 用于在序列化时正确地输出值
func (m *MessageValue) MarshalJSON() ([]byte, error) {
    if m.Type == "string" {
        return json.Marshal(m.StringValue)
    }
    if m.Type == "array" {
        return json.Marshal(m.ArrayValue)
    }
    return []byte("null"), nil
}
'''

    def _snake_to_pascal(self, snake_str: str) -> str:
        """将 snake_case 转换为 PascalCase"""
        return self.type_mapper.snake_to_pascal(snake_str)

    def generate_all_apis(self, apis: List[APIDefinition]) -> str:
        """
        生成所有 API 的模型代码

        Args:
            apis: API 定义列表

        Returns:
            生成的 Go 代码
        """
        code_parts = [self.generate_model_file_header()]

        # 添加 MessageValue 类型定义
        code_parts.append(self.generate_message_value_type())
        code_parts.append("\n\n")

        # 生成每个 API 的模型
        for api_def in apis:
            code_parts.append(self.generate_api_models(api_def))
            code_parts.append("\n\n")

        return "\n".join(code_parts)
